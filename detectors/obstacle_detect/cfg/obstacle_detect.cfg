#!/usr/bin/env python3
PACKAGE = "obstacle_detect"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator() 

gen.add("min_range", double_t, 0, "Min ROI", 0.3, 0.15, 1)
gen.add("max_range", double_t, 0, "Max ROI", 1.01, 12, 7)

gen.add("use_split_and_merge", bool_t, 0, "Iterative End Point Fit (0) or Split And Merge (1) ", True)     
gen.add("detect_only_visible_circle", bool_t, 0, "Detect circle only from fully visible (not occluded) segments", True)
gen.add("publish_seg_of_circle", bool_t, 0, "Publish circle\'s segments", False)

gen.add("min_group_points", int_t, 0, "Min points to be considered as a group", 10, 5, 150)

gen.add("max_group_distance", double_t, 0, "Start a new group if the distance between two points is greater", 0.2, 0.05, 1)
gen.add("distance_proportion", double_t, 0, "The allowable distance between points proportionally to the range of point (use scan angle increment in radians)", 0.00628, 0.001, 0.01)
gen.add("max_split_distance", double_t, 0, "Split the group if a point in group lays further from a leading line", 0.05, 0.01, 0.5) # relative with max_group_distance
gen.add("max_merge_separation", double_t, 0, "Consider merging obstacles if distance between is smaller", 0.2, 0.01, 0.5)
gen.add("max_merge_spread", double_t, 0, "Merge two segments if all their extreme points lay close to the leading line", 0.2, 0.01, 0.5)
gen.add("max_circle_radius", double_t, 0, "Skip circle circle has greater radius than this value", 0.6, 0.1, 2)

exit(gen.generate(PACKAGE, "obstacle_detect", "obstacleDetect"))